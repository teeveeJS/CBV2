const Board = require("board");
const FEN = require("FEN");
const isLegal = require("isLegal");
const Coordinates = require("coordinates");
const color = require("utils").color;
const readline = require("readline");

class Game {
  constructor(player1, player2, fromFEN) {
    this.white = player1 || "white";
    this.black = player2 || "black";

    this.board = (fromFEN !== undefined) ? FEN.toBoardObject(fromFEN) : new Board();

    this.moves = [];

    this.inProgress = true;
    this.result;
  }

  manualGameEnd(str) {
    //checks for the termination of the game
    if (str.toUpperCase() === "RESIGN") {
      return (this.board.move_white) ? "0-1" : "1-0";
    } else if (str.toUpperCase() === "DRAW") {
      return "1/2-1/2";
    } else if (str.toUpperCase() === "ADJOURN") {
      return "*";
    } else {
      return null;
    }
  }

  loop() {
    if (this.inProgress) {
      // check for game termination (checkmate and stalemate)
      if (this.board.isCheckmate()) {
        console.log("Checkmate!");
        this.end((!this.board.move_white) ? "1-0" : "0-1");
        return;
      } else if (this.board.isStalemate()) {
        console.log("Stalemate!");
        this.end("1/2-1/2");
        return;
      }

      // print the position
      this.board.printBoard(this.board.move_white);

      this.getMove();
    }
  }

  end(result) {
    this.result = result;
    this.inProgress = false;
    console.log("The game has finished: " + this.result);
  }

  getMove() {
    // get the user input
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    // let userInput = prompt(((this.board.move_white) ? "White" : "Black") + " to move.");
    let toMoveMsg = (this.board.move_white ? "White" : "Black") + " to move.\n";
    // TODO: take care of this callback hell
    rl.question(toMoveMsg, (userInput) => {
      // check for manual game termination
      let res = this.manualGameEnd(userInput)
      if (res !== null) {
        rl.close();
        this.end(res);
        return;
      }

      let move;
      let piece;
      // other validity checks on the user input
      try {
        move = Coordinates.alfToNum(userInput);
        piece = this.board.getPiece(move.start.num, move.start.alf);
      } catch (e) {
        console.log("Invalid move! " + e);
        rl.close();
        this.loop();
        return;
      }

      if (!this.board.move_white && color(piece) ||
           this.board.move_white && !color(piece)) {
        console.log("Not your turn");
        rl.close();
        this.loop();
        return;
      }

      // check whether the move is legal
      if (isLegal(piece, move, this.board)) {
        if (this.board.isPromotion(move)) {
          const promInput = readline.createInterface({
            input: process.stdin,
            output: process.stdout
          });
          promInput.setPrompt("Promote to Q|R|B|N: ");
          promInput.prompt();
          promInput.on("line", (pp) => {
            if (pp === "Q" || pp === "R" || pp === "B" || pp === "N") {
              pp = (this.board.move_white) ? pp.toUpperCase() : pp.toLowerCase();
              console.log(Coordinates.toAlgebraic(piece, move, this.board, pp));
              this.moves.push(move);

              this.board = this.board.movePieces(piece, move, pp);

              promInput.close();
            } else {
              promInput.prompt();
            }
          });
        } else {
          console.log(Coordinates.toAlgebraic(piece, move, this.board, null));
          this.moves.push(move);

          this.board = this.board.movePieces(piece, move, null);
        }
      } else {
        console.log("Illegal move");
        rl.close();
        this.loop();
        return;
      }

      rl.close();

      this.loop();
      return;
    });
  }

  exportGame() {
    // - export to a new .pgn file
    // - export to an existing .pgn file

  }
}

// export { Game };
module.exports = Game;
