const FEN = require("fen");
const isLegal = require("isLegal");
const isLegalBishop = require("bishop");
const isLegalKing = require("king").isLegalKing;
const isLegalKnight = require("knight");
const isLegalPawn = require("pawn").isLegalPawn;
const getPawnThreats = require("pawn").getPawnThreats;
const isLegalRook = require("rook").isLegalRook;
const Coordinates = require("coordinates");
const Utils = require("utils");
const color = Utils.color;

class Board {
  static copyBoard(b) {
    // copies the 8x8 board entity
    let copy = Utils.empty8x8();
    for (let i = 0; i < 8; i++) {
      for (let j = 0; j < 8; j++) {
        copy[i][j] = b[i][j];
      }
    }
    return copy;
  }

  static copyBoardObject(b) {
    let copy = new Board(Board.copyBoard(b.entity), b.move_white, b.castling,
      b.wK_loc, b.bK_loc, b.enPassantSquare, b.move_number, b.halfMoveCount);
    // TODO: castling object may not be immutable
    return copy;
  }

  static boardFromFEN(fen) {
    let board = new Board(FEN.toBoardArray(fen));
    board.enPassantSquare = FEN.enPassantSquare(fen);
    board.move_number = FEN.fullmove(fen);
    board.halfMoveCount = FEN.halfmove(fen);
    board.castling = FEN.castling(fen);
    return board;
  }

  static findKing(side, entity) {
    let k = side ? "K" : "k";

    for (let i = 0; i < 8; i++) {
      for (let j = 0; j < 8; j++) {
        if (entity[i][j] === k) return {num: i, alf: j};
      }
    }
    throw "Error: King not found";
  }

  constructor(init_pos, toMove, castles, wkpos, bkpos, epsq, mcount, hmcount) {
    if (init_pos === undefined) {
      this.entity = FEN.toBoardArray(FEN.INIT_FEN);
    } else if (typeof init_pos === "string") {
      this.entity = FEN.toBoardArray(init_pos);
    } else {
      this.entity = init_pos;
    }

    this.move_white = (toMove !== undefined) ? toMove : true;
    this.castling = castles || {
      whiteKing: true,
      whiteQueen: true,
      blackKing: true,
      blackQueen: true
    };
    // TODO: handle possible error from findKing
    this.wK_loc = wkpos || Board.findKing(true, this.entity);
    this.bK_loc = bkpos || Board.findKing(false, this.entity);
    this.enPassantSquare = epsq || null;
    this.move_number = mcount || 1;
    this.halfMoveCount = hmcount || 0; // used for tracking 50 move rule
  }

  at(x, y) {
    return this.entity[x][y];
  }

  // clear_empty() {
  //   this.entity = Board.empty8x8();
  // }
  //
  // clear_start() {
  //   this.entity = FEN.toBoardArray(INIT_FEN);
  // }

  getPiece(num, alf) {
    if (this.isSqEmpty(num, alf)) throw "Error: No piece found at num=" + num + ", alf=" + alf;
    else return this.at(num, alf);
  }

  hasPiece(num, alf) {
    return this.at(num, alf) !== undefined;
  }

  isCapture(move) {
    return this.at(move.end.num, move.end.alf) !== undefined;
  }

  isCastle(move) {
    // TODO: currently this is easy to trick if invoked from a wrong context
    return this.getPiece(move.start.num, move.start.alf).toUpperCase() === "K" &&
           Math.abs(move.start.alf - move.end.alf) === 2;
  }

  isPawnDoubleMove(move) {
    try {
      let p = this.getPiece(move.start.num, move.start.alf);
      let deltaAlf = Math.abs(move.end.alf - move.start.alf);
      let deltaNum = move.end.num - move.start.num;
      let dir = color(p) ? 1 : -1;
      let startNum = color(p) ? 1 : 6;
      return p === "p" &&
             deltaAlf === 0 && dir * deltaNum === 2 &&
             move.start.num === startNum &&
             this.isSqEmpty(move.end.num - dir, move.end.alf) &&
             this.isSqEmpty(move.end.num, move.end.alf);
    } catch (e) {
      console.log(e);
      return false;
    }
  }

  isPromotion(move) {
    let p = this.getPiece(move.start.num, move.start.alf);
    return p === "p" &&
           color(p) && move.end.num === 7 ||
           !color(p) && move.end.num === 0;
  }


  isEnPassant(move) {
    let piece = this.getPiece(move.start.num, move.start.alf);
    let deltaAlf = Math.abs(move.end.alf - move.start.alf);
    let deltaNum = move.end.num - move.start.num;
    let dir = color(piece) ? 1 : -1;
    return piece === "p" &&
           deltaAlf === 1 && dir * deltaNum === 1 &&
           Coordinates.sqEquals(move.end, this.enPassantSquare);
  }

  isSqEmpty(num, alf) {
    return !this.hasPiece(num, alf);
  }

  isUnderAttack(sq, side) {
    // similar to isCheck??
  }

  threatens(sq1, sq2) {
    // returns true if piece on sq1 can attack piece on sq2
    if (this.isSqEmpty(sq1.num, sq1.alf)) {
      return false;
    }

    let piece = this.getPiece(sq1.num, sq1.alf);
    let move = {
      start: sq1,
      end: sq2
    };

    switch (piece.toUpperCase()) {
      case "R": return isLegalRook(move, this);
      case "B": return isLegalBishop(move, this);
      case "N": return isLegalKnight(move, this);
      case "Q": return isLegalRook(move, this) || isLegalBishop(move, this);
      case "K": return isLegalKing(move);
      case "P": return getPawnThreats(piece, sq1).some((sq) => Coordinates.sqEquals(sq, sq2));
    }
  }

  getMoves(sq) {
    // returns a list of all legal moves of the piece on sq
    // super inefficient brute force method
    // TODO: have separate functions (like isLegal) to generate the possible moves for each piece
    if (this.isSqEmpty(sq.num, sq.alf)) {
      return [];
    }

    let piece = this.getPiece(sq.num, sq.alf);
    let moves = [];

    for (let i = 0; i < 8; i++) {
      for (let j = 0; j < 8; j++) {
        let sq2 = {num: i, alf: j};
        let move = {start: sq, end: sq2};
        if (isLegal(piece, move, this)) {
          moves.push(move);
        }
      }
    }

    return moves;
  }

  getAllMoves() {
    // return a list of all the legal moves
    let moves = [];

    for (let i = 0; i < 8; i++) {
      for (let j = 0; j < 8; j++) {
        if (this.hasPiece(i, j) && color(this.at(i, j)) === this.move_white) {
          moves = moves.concat(this.getMoves({num: i, alf: j}));
        }
      }
    }

    return moves;
  }

  isCheck(side, customSq) {
    // side <- true => is white king in check?
    // side <- false =>> is black king in check?
    // TODO: for this, it might be useful to have two private class variables
    // that keep track of the position of each player's king

    if (side === undefined) side = this.move_white;
    let k = (customSq === undefined) ? (side ? this.wK_loc : this.bK_loc) : customSq;

    for (let i = 0; i < 8; i++) {
      for (let j = 0; j < 8; j++) {
        if (this.hasPiece(i, j) && color(this.at(i, j)) === !side) {
          if (this.threatens({num: i, alf: j}, k)) return true;
        }
      }
    }
    return false;
  }

  isCheckmate() {
    return this.getAllMoves().length === 0 && this.isCheck();
  }

  isStalemate() {
    return this.getAllMoves().length === 0 && !this.isCheck();
  }

  movePieces(piece, move, promPiece) {
    // for immutability, copy the current board object to a new board object
    // only the new object will be _updated_ from here on out
    let b = Board.copyBoardObject(this);

    // reset the initial square
    b.entity[move.start.num][move.start.alf] = undefined;
    //move the piece to its new square
    b.entity[move.end.num][move.end.alf] = piece;

    // special conditions
    if (this.isPromotion(move)) {
      // promotion defaults to queen
      // TODO: have a promDefault variable
      b.entity[move.end.num][move.end.alf] = (promPiece) ? promPiece : (this.move_white) ? "Q" : "q";
    }

    if (this.isPawnDoubleMove(move)) {
      let dir = color(piece) ? 1 : -1;
      b.enPassantSquare = {
        alf: move.start.alf,
        num: move.start.num + dir
      };
    } else {
      b.enPassantSquare = null;
    }

    // update castling rights and king location
    if (piece === "K") {
      b.wK_loc = move.end;
      b.castling.whiteKing = false;
      b.castling.whiteQueen = false;
    } else if (piece === "k") {
      b.bK_loc = move.end;
      b.castling.blackKing = false;
      b.castling.blackQueen = false;
    } else if (piece.toUpperCase() === "R") {
      switch (move.start.alf + 10*move.start.num) {
        case 0:
          b.castling.whiteQueen = false;
          break;
        case 7:
          b.castling.whiteKing = false;
          break;
        case 70:
          b.castling.blackQueen = false;
          break;
        case 77:
          b.castling.blackKing = false;
          break;
        default:
          break;
      }
    }

    // if (this.isCapture(m)) {
    // only relevant in graphics
    // }

    if (this.isCastle(move)) {
      // move the corresponding rook
      let rook = (move.start.num === 0) ? "R" : "r";
      if (move.start.alf > move.end.alf) {
        // could eliminate redundancy even further at the expense of readability
        // castles queenside
        b.entity[0][move.start.num] = undefined;
        b.entity[3][move.start.num] = rook;
      } else {
        // castles kingside
        b.entity[7][move.start.num] = undefined;
        b.entity[5][move.start.num] = rook;
      }
    }

    if (this.isEnPassant(move)) {
      b.entity[move.start.num][move.end.alf] = undefined;
    }

    b.move_white = !b.move_white;
    b.halfMoveCount++;
    if (b.move_white) b.move_number++;

    return b;
  }

  printBoard(white_bottom) {
    // white_bottom === true => board will be printed with white on bottom (normal)

    let flip_i = (white_bottom) ? 7 : 0;
    let flip_j = (white_bottom) ? 0 : 7;
    //console.clear();
    for (let i = 0; i < 8; i++) {
      let i_f = Math.abs(flip_i - i);
      let str = "";
      for (let j = 0; j < 8; j++) {
        let j_f = Math.abs(flip_j - j);
        if (this.at(i_f, j_f) !== undefined) {
          str += this.at(i_f, j_f) + " ";
        } else {
          str += "  ";
        }
      }
      console.log(String(i_f + 1) + " " + str);
    }

    let letters = (white_bottom) ? ". a b c d e f g h" : ". h g f e d c b a";
    console.log(letters);
  }
}

// export { Board };
module.exports = Board;
